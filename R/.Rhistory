else{
print(SMILES)
}
}
custom_table[is.na(custom_table)] <- 0
custom_table <- custom_table %>%
filter(rowname != "row")
names(custom_table) <- c("SMILES", col_names_custom)
#ringsystems
# list <- read_delim("ringsystem_fingerprints_names.txt", delim = ",") %>%
#   mutate(row = as.numeric(rowRing)) %>%
#   select(row)
row <- c(1:113)
list <- as.data.frame(row)
smartslistring <- c("[CH1]([CH1][OH0][CH1]-1~[#7])([CH1]-1~[#8])~[#8]","c(:c(:c(:c:c:1):o:c:c:2):c:2):c:1","C(C(C(C(C-1~[#8])~[#8])~[#8])~[#8])(C-1~[#8])~[#8]",
"c(:c:o:c(:c:c(:c:c:1~[#8])~[#8]):c:1:2):c:2~[#8]","c(:c(:c:c:c:1~[#17])~[#8]):c:1~[#8]","c(:c(:n:c(:n:1)~[#8])~[#7])(:c:1~[#8])~[#7]",
"c(:c(:c:c:c:1)~[#8]):c:1","C(CC(OC=1)~[#8])C=1","c(:c:c:c:c:1:c:c:n:2):c:1:2","c(:c(:c:c:c:1)~[#16]):c:1",
"[CH1]([CH1][CH1]([CH2]-1)~[#8])[CH1]-1~[#8]","c(:c:o:c:c:1):c:1~[#8]","c(:c(:n:c(:n:1)~[#7])~[#7]):c:1~[#8]",
"C(CCC(C-1CCC-2)C-2)(C-1CC=C-3C(C(CC-4)CCC-5)C-5)C-3-4",  "c(:c:c(:c:n:n:1):c:1:c:2):c:2","c(:c(:c:c:c:1CCCO-2)~[#8]):c:1-2",
"C(CCOC-1~[#8])C-1","c(:c:c:c:c:1):c:1~[#7]","c(:c:c:c(:c:1C(C-2)~[#8])N-2):c:1","c(:c(:c(:c:c:1)~[#8])~[#8])(:c:1)~[#8]",
"C(CCC-1)(C-1)~[#8]","c(:c(:c:c(:c:1)~[#8])~[#8])(:c:1~[#8])~[#8]","c(:n:c:c:1):n:1","c(:n:c:n:1):n:1",
"C(C(C(OC-1)~[#8])~[#7])(C-1~[#8])~[#8]","[CH1]([CH2][CH2][CH0][CH1]-1)[CH1]-1","c(:c(:c:c:c:1:c:c:c(:o:2)~[#8])~[#8]):c:1:2",
"c(:n:c:n:c:1~[#7])(:c:1)~[#7]","n(:c:c:c:c:1):c:1","C(COC-1)C-1","C(CCCC-1CC(CC-2)~[#8])C-1-2","C(C(COC-1)~[#8])(C-1~[#8])~[#8]",
"c(:c:o:c(:c:c(:c:c:1~[#8])~[#8]):c:1:2)(:c:2)~[#8]","[CH1]([CH0][CH2][CH2][CH2]-1)[CH0]-1","c(:c(:c:c(:c:1[CH0]([CH1][CH1][OH0]-2)~[#8])~[#8])~[#8]):c:1-2",
"C(CCC(C-1CCC-2CCC-3)C-2-3)C-1","c(:c:c:n:c:1~[#8]):n:1","n(:c:c:c(:c:1:c:c:c:c:2)~[#8]):c:1:2",   "[CH1]([CH1][CH1]([CH2]-1)~[#8])[CH0]-1~[#8]",
"c(:c(:c:c(:c:1)~[#8])~[#8]):c:1~[#8]","c(:c:c:c(CCCC-1):c-1:2):c:2","C(CCCC-1~[#8])(C-1)~[#8]",
"[CH1]([CH2][CH1][OH0][CH1]-1)[CH1]-1","c(:c:c(:c(:c:c:c:o:1):c:1:2)~[#8])(:c:2)~[#8]",
"[CH0]([CH1]([CH1]([CH1]=[CH1][OH0]-1)[CH1]-2~[#8])[CH1]-1~[#8])([CH1]-2-3)[OH0]-3",
"C(CCC(C-1CC(C-2~[#8])~[#8])C-2)(C-1CC=C-3C(C(CC-4)CCC-5)C-5)C-3-4","[CH0]([CH2][CH2][CH1][CH0]-1)[CH1]-1",
"C(CC(C-1)~[#8])C-1~[#8]","c(:c:c:c(:c:1)~[#9])(:c:1)~[#7]","C(COC-1)(C-1)~[#8]","c(:n:c:n:c:1~[#7])(:c:1)~[#8]",
"c(:c:c:n:c:1~[#7]):n:1","c(:c(:c(:c(:c:1)~[#8])[CH0]([CH2][CH1]-2)~[#8])[OH0]-2):c:1~[#8]","C(CCCC-1~[#8])C-1",
"n(:c:c:c:1):c:1","c(:c:c(:n:c:1)~[#8]):n:1","c(:c:o:c(:c:c:c:c:1):c:1:2)(:c:2~[#8])~[#8]",
"[CH1]([CH2][CH2][CH0][CH1]-1)[CH2]-1","[CH0]([CH1][CH2][CH2]-1)[CH0]-1~[#8]","c(:n:c:n:c:1)(:c:1)~[#7]",
"C(C(COc:1:c:c(:c:c:2)~[#8])~[#8])c:1:2","c(:c:c(:c(:c:1:c:c:c:2~[#8]):c:2)~[#8]):o:1","c(:c(:c:c:c:1~[#8])~[#8])(:c:1)~[#8]",
"C(C=CCC-1CCCC-2)C-1-2","C(CCC(C-1CC(C-2CCC-3)~[#8])C-2-3)C-1","c(:c:c(:c(:c:1:c:c:c:2~[#8]):c:2~[#8])~[#8]):o:1",
"C(CCCC-1CCCC-2)C-1-2","[CH0]([CH2][CH2][CH1]([CH0]-1)~[#8])([CH1]-1[CH2][CH2][CH0]-2)[CH1]-2","C(CCC-1CCCC-2)C-1-2",
"C(CC(CC-1~[#8])~[#8])(C-1~[#8])~[#8]","C(CC(C-1)~[#8])(O-1)~[#7]","C(CC(CC-1~[#8])~[#8])O-1","c(:c:c:c:c:1OCCC-2~[#8])(:c:1-2)~[#8]",
"C(CCC-1C(C(CC-2)C(C(C-3)CC(C-4)~[#8])C-4)C-3)C-1-2",
"c(:n:c(:n:c:1)~[#8])(:c:1)~[#7]","C(C(C(C-1)~[#8])~[#8])O-1",
"[CH0]([CH1]([CH2][CH2][CH0]([CH1]-1[CH2][CH1]=[CH0]-2[CH1]([CH0]([CH2][CH2]-3)[CH2][CH2][CH0]-4)[CH2]-4)[CH0]-2-3)[CH0]-1[CH2][CH2]-5)[CH1]-5~[#8]",
"[CH1]([CH0]-1)[OH0]-1","C(=COCC-1CCC-2)C-1-2","n(:c:n:c:1:c(:n:c:n:2)~[#7]):c:1:2","C(CCc(:c:c:c:c:1):c:1-2)O-2",
"c(:c:o:c(:c:1:c:c:c:2~[#8]):c:2)(:c:1~[#8])~[#8]","[CH0](=[CH1][OH0][CH1][CH1]-1)[CH1]-1","c(:c:c(:n:c:1~[#7])~[#7]):n:1",
"c(:c:c(:c:c:1)~[#8]):n:1","C(C=CC-1~[#8])O-1","c(:n:n:c:1):c:1","c(:c(:c(:c(:c(:c:c(:c:1)~[#8])~[#8]):c:1:2)~[#8])~[#8]):o:2",
"[CH1]([CH1][CH1][CH1]-1)[OH0]-1","[CH0]([CH1][CH0][CH2][CH2]-1)[CH0]-1","c(:c:c:c:c:1:n:c:n:2):c:1:2","n(:c:n:c:1:c(:n:c:n:2)~[#8]):c:1:2",
"c(:n:c:n:c:1:n:c:n:2):c:1:2","c(:n:c:c:c:1~[#8])(:n:1)~[#7]",  "[CH0]([CH2][CH2][CH0][CH1]-1)[CH2]-1","[CH0](=[CH1][CH0]([OH0]-1)~[#8])[CH2]-1","c(:c:n:c(:n:1)~[#8]):c:1~[#8]",
"C(COc(:c:c:c:c:1):c:1-2)(C-2~[#8])~[#8]","c(:c(:c:c(:c:c:c(:c:1)~[#8]):c:1:2)~[#8]):o:2","[CH2]([CH2][CH1][CH0][CH1]-1)[CH1]-1",
"c(:c(:c:c(:c:1:o:c:c:2):c:2~[#8])~[#8])(:c:1)~[#8]","C(COc(:c:c:c:c:1):c:1-2)C-2~[#8]","C(CC=CO-1)C-1",
"[CH0]([CH2][CH2][CH1]([CH0]-1)~[#8])[CH1]-1","C(COC-1~[#8])C-1","C(COC-1~[#8])(C-1~[#8])~[#8]","n(:c:c:n:1):c:1~[#16]",
"[CH1]([CH1][CH1][CH1][CH2]-1)[OH0]-1","c(:n:c:n:c:1:c:c:c:c:2)(:c:1:2)~[#8]","[CH1]([CH1][CH1]([CH2][CH1]-1~[#8])~[#8])[OH0]-1",
"c1ccccc1-c","[cD2]1ccc[cD2]c1-c(c)c",
"[C](-,=[C]-,=1)-,=[C](-,=[C]-,=2)-[C](-,=[C]-,=[C]-,=[C]-,=2-,=[O])-,=[C](-,=[C]-,=3)-,=[C]-,=1-,=[C](-,=[C]-,=4)-,=[C](-,=[C]-,=3)-,=[C]-,=[C]-,=4")
col_names_ring <- c("Un8468","Un8480","Un8483","Un8484","Un8486","Un8489","Un8491","Un8494","Un8495","Un8496","Un8497","Un8498",
"Un8501","Un8502","Un8505","Un8516","Un8521","Un8524","Un8529","Un8539","Un8540","Un8541","Un8542","Un8546",
"Un8547","Un8553","Un8556","Un8558","Un8559","Un8563","Un8566","Un8568","Un8575","Un8581","Un8582","Un8584",
"Un8585","Un8587","Un8588","Un8589","Un8606","Un8607","Un8610","Un8611","Un8618","Un8619","Un8620","Un8632",
"Un8635","Un8637","Un8638","Un8641","Un8647","Un8648","Un8651","Un8655","Un8663","Un8664","Un8670","Un8673",
"Un8677","Un8678","Un8682","Un8686","Un8691","Un8692","Un8698","Un8706","Un8710","Un8723","Un8724","Un8730",
"Un8736","Un8740","Un8743","Un8749","Un8750","Un8751","Un8758","Un8760","Un8767","Un8770","Un8772","Un8777",
"Un8779","Un8782","Un8783","Un8788","Un8789","Un8797","Un8802","Un8808","Un8814","Un8820","Un8834","Un8843",
"Un8849","Un8852","Un8854","Un8858","Un8860","Un8864","Un8871","Un8874","Un8881","Un8888","Un8889","Un8901",
"Un8903","Un8908","Un8922","Un8923","Un8924")
ring_table <- as.data.frame(t(list)) %>%
rownames_to_column()
for (n in 1:length(compoundslist_onlySMILES$SMILES)){
#col <- compoundslist$id[[n]]
SMILES <- compoundslist_onlySMILES$SMILES[[n]]
mol2 <- parse.smiles(SMILES)[[1]]
if(!is.null(mol2)){
ring_fingerprints <- get.fingerprint(mol2,
type = "substructure",
substructure.pattern = smartslistring)
table <- as.data.frame(ring_fingerprints@bits) %>%
mutate(fp = 1) %>%
mutate(fp = as.numeric(fp))
colnames(table) <- c("row", SMILES)
table <- table %>%
mutate(row = as.numeric(row))
suppressMessages(datarow <- list %>%
left_join(table) %>%
select(-row))
newrow <- as.data.frame(t(datarow)) %>%
rownames_to_column()
ring_table <- ring_table %>%
add_row(newrow)
}
else{
print(SMILES)
}
}
ring_table[is.na(ring_table)] <- 0
ring_table <- ring_table %>%
filter(rowname != "row")
names(ring_table) <- c("SMILES", col_names_ring)
#Combining all FP together
suppressMessages(allFP_table <- substr_table %>%
left_join(maccs_table) %>%
left_join(pubchem_table) %>%
left_join(KlekotaRoth_table) %>%
left_join(custom_table) %>%
left_join(ring_table))
suppressMessages(descs <- compoundslist %>%
left_join(allFP_table))
} else if(type == "PaDEL") {
SMILES_list = compoundslist %>%
select(SMILES) %>%
unique() %>%
na.omit() %>%
mutate(Name = row_number())
compoundslist = compoundslist %>%
left_join(SMILES_list)
write_delim(SMILES_list %>% select(SMILES) %>% unique(),
"SMILES.smi",
col_names = FALSE)
command = "java -jar R/PaDEL-Descriptor/PaDEL-Descriptor.jar -dir" #file name where they will be calculated
command_final = paste(command, "SMILES.smi", "-file", "R/descs_calc.csv", "-2d", sep =" ") #makes text for command prompt
javaOutput = system(command_final, intern = TRUE) #goes into commant prompt
#PaDEL saves the descriptors to the local folder
descs = read_delim("R/descs_calc.csv",
delim = ",",
col_names = TRUE)
if (length(unique(SMILES_list$SMILES)) == 1) {
descs = descs %>%
mutate_all(~replace(., str_detect(., "Infinity"), as.numeric(0))) %>%
mutate(Name = 1)
} else {
descs = descs %>%
mutate_all(~replace(., str_detect(., "Infinity"), as.numeric(0))) %>%
group_by(Name) %>%
mutate(Name = str_split(Name, pattern = "_")[[1]][length(str_split(Name, pattern = "_")[[1]])]) %>%
ungroup() %>%
mutate(Name = as.integer(Name))
}
cols <- names(descs)
descs[cols] <- lapply(descs[cols], as.numeric)
descs = descs %>%
left_join(compoundslist) %>%
select(colnames(compoundslist), everything()) %>%
select(-Name)
}
return(descs)
}
#' @export
organicpercentage <- function(eluent_parameters,ret_time){
ApproxFun <- approxfun(x = eluent_parameters$time, y = eluent_parameters$B)
organic <- ApproxFun(ret_time)
return(organic)
}
#' @export
polarityindex <- function(organic,organic_modifier){
polarity_index <- case_when(
organic_modifier == "MeCN" ~ (organic/100)*5.1+((100-organic)/100)*10.2,
organic_modifier == "MeOH" ~ (organic/100)*5.1+((100-organic)/100)*10.2)
return(polarity_index)
}
#' @export
surfacetension <- function(organic,organic_modifier){
surface_tension <- case_when(
organic_modifier == "MeCN" ~ 71.76-2.906*71.76*(organic/100)+(7.138*27.86+2.906*71.76-71.76)*(organic/100)^2+(27.86-7.138*27.86)*(organic/100)^3,
organic_modifier == "MeOH" ~ 71.76-2.245*71.76*(organic/100)+(5.625*22.12+2.245*71.76-71.76)*(organic/100)^2+(22.12-5.625*22.12)*(organic/100)^3)
return(surface_tension)
}
#' @export
viscosity <- function(organic,organic_modifier){
viscosity <- case_when(
organic_modifier == "MeCN" ~ (-0.000103849885417527)*organic^2+0.00435719229180079*organic+0.884232851261593,
organic_modifier == "MeOH" ~ (-0.00035908)*organic^2+0.031972067*organic+0.90273943)
return(viscosity)
}
#' @export
add_mobile_phase_composition = function(data,
eluent,
organic_modifier = "MeCN",
pH_aq = 7.0,
NH4 = 0) {
if("retention_time" %in% colnames(data) == T) {
if (is.character(eluent)) {
eluent = read_delim(eluent,
delim = ",",
col_names = TRUE,
show_col_types = FALSE)
}
data = data %>%
mutate(organic_modifier_percentage = organicpercentage(eluent, retention_time))
}
data = data %>%
mutate(viscosity = viscosity(organic_modifier_percentage, organic_modifier),
surface_tension = surfacetension(organic_modifier_percentage, organic_modifier),
polarity_index = polarityindex(organic_modifier_percentage, organic_modifier),
organic_modifier = organic_modifier,
pH_aq = pH_aq,
NH4 = NH4)
return(data)
}
#' Isotope distribution
#'
#' This function calculates isotopic abundance for a chemical based on SMILES notation. This number can later be used as a coefficient to multiply the area corresponding to
#' a monoisotopic ion.
#'
#' @param smiles SMILES notation of the compound
#' @return isotopic abundance coefficient
#' @examples
#' isotopedistribution("CN1C=NC2=C1C(=O)N(C(=O)N2C)C")
#' @export
isotopedistribution <- function(smiles){
#convert SMILES to chemical formula
molecule <- parse.smiles(smiles)[[1]]
formula <- get.mol2formula(molecule,charge=0)
formula <- formula@string
# Chemical formula to isotope distribution
data(isotopes, package = "enviPat")
pattern<-isopattern(isotopes,
formula,
threshold=0.1,
plotit=FALSE,
charge=FALSE,
algo=1)
isotopes <- as.data.frame(pattern[[1]])
isotope_dist <- as.numeric(sum(isotopes$abundance))
return(isotope_dist)
}
#' @export
summarized_SIRIUS_identification_results <- function(folder) {
setwd(folder)
subfolder <- dir(folder, all.files = TRUE, recursive = TRUE, pattern = "*.tsv")
compiled_data <- tibble()
for (filename in subfolder) {
if (grepl("/structure_candidates", filename, fixed=TRUE)){
comp_name <- str_split(filename, "/")
folder_name = comp_name[[1]][1]
folder_number <- as.numeric(str_split(folder_name, "_")[[1]][1])
id <- as.character(tail(str_split(folder_name, "_")[[1]], n=1)) # id is taken as the last element of the folder name after splitting the string by underscores
data_smile <- read_delim(filename, delim = "\t")
if (dim(data_smile)[1] > 0) {
data_smile_notempty <- data_smile %>%
select(rank, formulaRank, molecularFormula, `CSI:FingerIDScore`, adduct, InChI, smiles) %>%
mutate(id = id,
folder_number = folder_number) %>%
rename(rank_withinFormula = rank,
siriusscore = `CSI:FingerIDScore`,
SMILES = smiles) %>%
select(id, folder_number, everything())
compiled_data <- compiled_data %>%
bind_rows(data_smile_notempty) %>%
unique()
}
}
}
compiled_data <- compiled_data %>%
mutate(siriusscore = as.numeric(siriusscore)) %>%
group_by(id, folder_number) %>%
arrange(desc(siriusscore)) %>%
mutate(rank = row_number()) %>%
ungroup()
return(compiled_data)
}
#' @export
FpTableForPredictions <- function(folderwithSIRIUSfiles){
#uncompressing the compressed files - in case there has been any updates in SIRIUS project, good if it is done again so that compressed files are up to date
all_files_in_SIRIUS_folder <- list.files(path = folderwithSIRIUSfiles, full.names = TRUE, recursive = TRUE)
exts <- file_ext(all_files_in_SIRIUS_folder)
all_dirs <- tibble(dirs = all_files_in_SIRIUS_folder,
exts = exts)
all_dirs <- all_dirs %>%
filter(exts == "")
if (length(all_dirs$dirs) > 0) {for (zipF in all_dirs$dirs){
outDir <- paste(zipF, "_uncompressed",
sep = "")
unzip(zipF, exdir = outDir)
}}
# FP calc
subfolder <- dir(folderwithSIRIUSfiles, all.files = TRUE, recursive = TRUE, pattern = ".fpt")
subfolder_score <- dir(folderwithSIRIUSfiles, all.files = TRUE, recursive = TRUE, pattern = ".info")
# find common fingerprints of pos and neg mode
fp_names_pos <- paste("Un", read_delim(paste(folderwithSIRIUSfiles,"/csi_fingerid.tsv", sep = ""), delim = "\t", show_col_types = FALSE)$absoluteIndex, sep = "")
fp_names_neg <- paste("Un", read_delim(paste(folderwithSIRIUSfiles,"/csi_fingerid_neg.tsv", sep = "" ), delim = "\t", show_col_types = FALSE)$absoluteIndex, sep = "")
fp_names_common = intersect(fp_names_pos, fp_names_neg)
selected_rank1_table <- FingerPrintTable(subfolder, fp_names_pos, fp_names_neg, fp_names_common, folderwithSIRIUSfiles) %>%
inner_join(SiriusScoreRank1(subfolder_score, folderwithSIRIUSfiles), by = c("id", "foldernumber", "predion"))
final_table_mass <- selected_rank1_table %>%
mutate(exactMass = "mass")
for(n in 1:length(final_table_mass$predform)){
formula <- get.formula(final_table_mass$predform[n])
final_table_mass$exactMass[n] <- formula@mass
}
final_table_mass <- final_table_mass %>%
mutate(exactMass = as.numeric(exactMass)) %>%
select(id, foldernumber, predform, predion, exactMass, everything())
return(final_table_mass)
}
#' @export
FingerPrintTable <- function(subfolder, fp_names_pos, fp_names_neg, fp_names_common, folderwithSIRIUSfiles){
subfolder_pos <- c()
subfolder_neg <- c()
fp_all = tibble()
for(subfold in subfolder){
if (( grepl("]+", subfold, fixed=TRUE)) & grepl("/fingerprint", subfold, fixed=TRUE)){
subfolder_pos <- subfolder_pos %>%
list.append(subfold)
}
if (( grepl("]-", subfold, fixed=TRUE)) & grepl("/fingerprint", subfold, fixed=TRUE)){
subfolder_neg <- subfolder_neg %>%
list.append(subfold)
}
}
# read in predicted FPs for pos and neg mode
if(!is.null(subfolder_pos)) {
fp_all <- read_in_fingerprints(subfolder_pos, folderwithSIRIUSfiles, fp_names_pos, fp_names_common)
}
if(!is.null(subfolder_neg)) {
fp_neg <- read_in_fingerprints(subfolder_neg, folderwithSIRIUSfiles, fp_names_neg, fp_names_common)
if(dim(fp_all)[1] > 0) {
fp_all <- fp_all %>%
bind_rows(fp_neg)
} else {
fp_all <- fp_neg
}
}
return(fp_all)
}
#' @export
read_in_fingerprints <- function(subfolder, folderwithSIRIUSfiles, names_all_columns, names_common){
fingerprint_data <- tibble()
for(direct in subfolder){
comp_name <- str_split(direct, "/")
folder_name = comp_name[[1]][1]
sir_fold <- as.numeric(str_split(folder_name, "_")[[1]][1])
id_this <- as.character(tail(str_split(folder_name, "_")[[1]], n=1)) # id is taken as the last element of the folder name after splitting the string by underscores
pred_ion <- as.character(sub("\\..*", "", comp_name[[1]][3]))
filedata <- read_delim(paste(folderwithSIRIUSfiles, direct, sep = "/"), delim = " ", col_names = FALSE, show_col_types = FALSE)
filedata <- as.data.frame(t(filedata))
filedata <- filedata %>%
mutate(predion = pred_ion,
id = id_this,
sir_fol_nr = sir_fold,
predform = as.character(sub("\\_.*", "", predion)))
fingerprint_data <- fingerprint_data %>%
bind_rows(filedata)
}
if(nrow(fingerprint_data) != 0){
colnames(fingerprint_data) <- c(names_all_columns, "predion", "id", "foldernumber", "predform")
fingerprint_data = fingerprint_data %>%
select(id, foldernumber, predform, predion, all_of(names_common))
}
return(fingerprint_data)
}
#' @export
SiriusScoreRank1 <- function(subfolder_score, folderwithSIRIUSfiles){
scores_table <- tibble()
for (filename in subfolder_score) {
if (grepl("/scores", filename, fixed=TRUE)){
comp_name <- str_split(filename, "/")
folder_name = comp_name[[1]][1]
foldernumber <- as.numeric(str_split(folder_name, "_")[[1]][1])
id <- as.character(tail(str_split(folder_name, "_")[[1]], n=1)) # id is taken as the last element of the folder name after splitting the string by underscores
predion <- as.character(sub("\\..*", "", comp_name[[1]][3]))
data_here = read_delim(paste(folderwithSIRIUSfiles, filename, sep = "/"), delim = "\t", col_names = F)
SiriusScore <- data_here %>%
filter(X1 == "sirius.scores.SiriusScore")
filedata <- tibble(id , foldernumber, predion) %>%
mutate(siriusscore = as.numeric(SiriusScore$X2))
if(dim(scores_table)[1] > 0) {
scores_table <- scores_table%>%
bind_rows(filedata)
} else {
scores_table = filedata
}
}
}
scores_table = scores_table %>%
filter(grepl("[M+H]+", predion, fixed = TRUE) | grepl("[M]+", predion, fixed = TRUE) | grepl("[M-H]-", predion, fixed = TRUE) | grepl("[M]-", predion, fixed = TRUE)) %>%
mutate(siriusscore = as.numeric(siriusscore)) %>%
mutate(siriusscore = round(siriusscore, 10)) %>%
unique()
data_scores <- scores_table %>%
select(-predion) %>% #if two compound have same siriusscore they get same rank
group_by(id, foldernumber) %>%
arrange(desc(siriusscore)) %>%
mutate(rank = row_number()) %>%
ungroup() %>%
left_join(scores_table,
by = c("id", "foldernumber", "siriusscore")) %>%
filter(rank == 1) %>%
select(-rank) %>%
unique()
return(data_scores)
}
#' @export
new_readin_FP_function <- function(folderwithSIRIUSfiles, all_files_uncompressed = FALSE, printouts = TRUE) {
original_wd = getwd()
#uncompressing the compressed files - in case there has been any updates in SIRIUS project, good if it is done again so that compressed files are up to date
all_files_in_SIRIUS_folder <- list.files(path = folderwithSIRIUSfiles, full.names = TRUE, recursive = TRUE)
exts <- file_ext(all_files_in_SIRIUS_folder)
all_dirs <- tibble(dirs = all_files_in_SIRIUS_folder,
exts = exts)
all_dirs <- all_dirs %>%
filter(exts == "")
if (length(all_dirs$dirs) > 0) {
if (all_files_uncompressed == FALSE) {
for (zipF in all_dirs$dirs){
outDir <- paste(zipF, "_uncompressed",
sep = "")
unzip(zipF, exdir = outDir)
}
}}
setwd(folderwithSIRIUSfiles)
# get dir to all features folders
all_dirs = list.dirs(path = folderwithSIRIUSfiles, full.names = F, recursive = FALSE)
# find common fingerprints of pos and neg mode
suppressMessages(
fp_names_pos <- paste("Un", read_delim(paste(folderwithSIRIUSfiles,"/csi_fingerid.tsv", sep = ""), delim = "\t", show_col_types = FALSE)$absoluteIndex, sep = "")
)
suppressMessages(
fp_names_neg <- paste("Un", read_delim(paste(folderwithSIRIUSfiles,"/csi_fingerid_neg.tsv", sep = "" ), delim = "\t", show_col_types = FALSE)$absoluteIndex, sep = "")
)
fp_names_common = intersect(fp_names_pos, fp_names_neg)
fingerprints_data_pos = tibble()
fingerprints_data_neg = tibble()
fingerprints_data = tibble()
if (printouts)  {
print(paste0("Found ", length(all_dirs), " SIRIUS folders", sep = " "))
}
ii = 1
##
for (dir in all_dirs) {
dir_files = list.files(dir)
formula_rank1 = ""
if ("fingerprints_uncompressed" %in% dir_files) {
dirs_FPs = list.files(paste0(dir, "/fingerprints_uncompressed", sep = ""), full.names = T)
if("formula_candidates.tsv" %in% dir_files) {
suppressMessages(
formula_candidates <- read_delim(paste0(dir, "/formula_candidates.tsv", sep = ""))
)
if(dim(formula_candidates)[1] > 0) {
formula_candidates = formula_candidates %>%
mutate(FP_exist = vapply(molecularFormula, function(x) any(grepl(x, dirs_FPs)), 1L)) %>%
filter(FP_exist == 1) %>%
filter(SiriusScore == max(SiriusScore))
formula_rank1 = formula_candidates$molecularFormula
if (length(formula_rank1) > 1) {
formula_rank1 = ""
}
}
}
}
if ("fingerprints_uncompressed" %in% dir_files & formula_rank1 != "") {
index_correct_formula_FP = grep(pattern = formula_rank1, dirs_FPs)
if (length(index_correct_formula_FP) == 1) {
dir_here = dirs_FPs[index_correct_formula_FP]
comp_name <- str_split(dir_here, "/")
folder_name = comp_name[[1]][1]
sir_fold <- as.numeric(str_split(folder_name, "_")[[1]][1])
id_this <- as.character(tail(str_split(folder_name, "_")[[1]], n=1)) # id is taken as the last element of the folder name after splitting the string by underscores
pred_ion <- as.character(sub("\\..*", "", comp_name[[1]][3]))
suppressMessages(
filedata <- read_delim(paste(folderwithSIRIUSfiles, dir_here, sep = "/"), delim = " ", col_names = FALSE, show_col_types = FALSE)
)
filedata <- as.data.frame(t(filedata))
filedata <- filedata %>%
mutate(predion = pred_ion,
id = id_this,
sir_fol_nr = sir_fold,
predform = as.character(sub("\\_.*", "", predion)))
# pos mode
if (grepl("]+", pred_ion, fixed=TRUE)) {
fingerprints_data_pos = fingerprints_data_pos %>%
bind_rows(filedata)
}
# neg mode
if (grepl("]-", pred_ion, fixed=TRUE)) {
fingerprints_data_neg = fingerprints_data_neg %>%
bind_rows(filedata)
}
}
}
ii = ii + 1
if (printouts)  {
print(paste0("file: ", ii, "; percentage: ",round(ii/length(all_dirs)*100), sep = ""))
}
}
if(nrow(fingerprints_data_pos) != 0){
colnames(fingerprints_data_pos) <- c(fp_names_pos, "predion", "id", "foldernumber", "predform")
fingerprints_data_pos = fingerprints_data_pos %>%
select(id, foldernumber, predform, predion, all_of(fp_names_common))
fingerprints_data = fingerprints_data %>%
bind_rows(fingerprints_data_pos)
}
if(nrow(fingerprints_data_neg) != 0){
colnames(fingerprints_data_neg) <- c(fp_names_neg, "predion", "id", "foldernumber", "predform")
fingerprints_data_neg = fingerprints_data_neg %>%
select(id, foldernumber, predform, predion, all_of(fp_names_common))
fingerprints_data = fingerprints_data %>%
bind_rows(fingerprints_data_neg)
}
if (printouts)  {
print("Done!")
}
setwd(original_wd)
return(fingerprints_data)
}
MS2Quant_predict_IE(tibble(SMILES = "CCCCCCC"))
library(MS2Quant)
MS2Quant_predict_IE(tibble(SMILES = "CCCCCCC"))
??parse.smiles
library(rscdk)
library(rcdk)
MS2Quant_predict_IE(tibble(SMILES = "CCCCCCC"))
??isopattern
library(enviPat)
MS2Quant_predict_IE(tibble(SMILES = "OC[C@H](O)[C@H]1OC(=O)C(O)=C1O"))
MS2Quant_predict_IE(tibble(SMILES = "OC[C@H](O)[C@H]1OC(=O)C(O)=C1O"), ionization =  "esi_neg")
data_list_sirius <- readRDS("inst/model/240906_neg_SIRIUS_xgbTree_allData.RData")
remove.packages("MS2Quant")
